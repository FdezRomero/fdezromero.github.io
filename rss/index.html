<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Rodrigo Fernández]]></title><description><![CDATA[Full-stack Javascript, Ionic & Startups]]></description><link>https://fdezromero.com/</link><image><url>https://fdezromero.com/favicon.png</url><title>Rodrigo Fernández</title><link>https://fdezromero.com/</link></image><generator>Ghost 2.12</generator><lastBuildDate>Wed, 06 Feb 2019 14:14:23 GMT</lastBuildDate><atom:link href="https://fdezromero.com/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[CORS Errors in Ionic Apps]]></title><description><![CDATA[CORS errors are common in web apps when a cross-origin request is made but the server doesn't return the required headers in the response. Learn how to fix them in this article.]]></description><link>https://fdezromero.com/cors-errors-in-ionic-apps/</link><guid isPermaLink="false">5c59c7b823af6334c2751b47</guid><category><![CDATA[Ionic]]></category><category><![CDATA[Web]]></category><dc:creator><![CDATA[Rodrigo Fernández]]></dc:creator><pubDate>Tue, 05 Feb 2019 17:30:00 GMT</pubDate><media:content url="https://fdezromero.com/content/images/2019/02/cors-error.png" medium="image"/><content:encoded><![CDATA[<h2 id="whatiscors">What is CORS?</h2>
<img src="https://fdezromero.com/content/images/2019/02/cors-error.png" alt="CORS Errors in Ionic Apps"><p><strong>Cross-Origin Resource Sharing (CORS)</strong> is a mechanism that browsers and webviews — like the ones powering Capacitor and Cordova — use to restrict HTTP and HTTPS requests made from scripts to resources in a different origin for security reasons, mainly to protect your user's data and prevent attacks that would compromise your app.</p>
<p>In order to know if an external origin supports CORS, the server has to send some <a href="#cors-headers">special headers</a> for the browser to allow the requests.</p>
<p>An <strong>origin</strong> is the combination of the <strong>protocol</strong>, <strong>domain</strong>, and <strong>port</strong> from which your Ionic app or the external resource is served. For example, apps running in Capacitor have <code>capacitor://localhost</code> (iOS) or <code>http://localhost</code> (Android) as their origin.</p>
<p>When the origin where your app is served (e.g. <code>http://localhost:8100</code> with <code>ionic serve</code>) and the origin of the resource being requested (e.g. <code>https://api.example.com</code>) don't match, the browser's <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">Same Origin Policy</a> takes effect and CORS is required for the request to be made.</p>
<p>CORS errors are common in web apps when a cross-origin request is made but the server doesn't return the required headers in the response (is not CORS-enabled):</p>
<blockquote>
  XMLHttpRequest cannot load https://api.example.com. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost:8100' is therefore not allowed access.
</blockquote>
<h2 id="howdoescorswork">How does CORS work</h2>
<h3 id="requestwithpreflight">Request with preflight</h3>
<p>By default, when a web app tries to make a cross-origin request the browser sends a <strong>preflight request</strong> before the actual request. This preflight request is needed in order to know if the external resource supports CORS and if the actual request can be sent safely, since it may impact user data.</p>
<p>A preflight request is sent by the browser if:</p>
<ul>
<li><strong>The method is:</strong>
<ul>
<li>PUT</li>
<li>DELETE</li>
<li>CONNECT</li>
<li>OPTIONS</li>
<li>TRACE</li>
<li>PATCH</li>
</ul>
</li>
<li><strong>Or if it has a header other than:</strong>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ul>
</li>
<li><strong>Or if it has a <code>Content-Type</code> header other than:</strong>
<ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
</li>
<li>Or if a <code>ReadableStream</code> or event listeners in <code>XMLHttpRequestUpload</code> are used.</li>
</ul>
<p>If any of the conditions above are met, a preflight request with the <code>OPTIONS</code> method is sent to the resource URL.</p>
<p>Let's suppose we are making a <code>POST</code> request to a fictional JSON API at <code>https://api.example.com</code> with a <code>Content-Type</code> of <code>application/json</code>. The preflight request would be like this (some default headers omitted for clarity):</p>
<pre><code class="language-http">OPTIONS / HTTP/1.1
Host: api.example.com
Origin: http://localhost:8100
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type
</code></pre>
<p>If the server is CORS enabled, it will parse the <code>Access-Control-Request-*</code> headers and understand that a <code>POST</code> request is trying to be made from <code>http://localhost:8100</code> with a custom <code>Content-Type</code>.</p>
<p>The server will then respond to this preflight with which origins, methods, and headers are allowed by using the <code>Access-Control-Allow-*</code> headers:</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://localhost:8100
Access-Control-Allow-Methods: GET, POST, OPTIONS
Access-Control-Allow-Headers: Content-Type
</code></pre>
<p>If the returned origin and method don't match the ones from the actual request, or any of the headers used are not allowed, the request will be blocked by the browser and an error will be shown in the console. Otherwise, the request will be made after the preflight.</p>
<p>In our example, since the API expects JSON, all <code>POST</code> requests will have a <code>Content-Type: application/json</code> header and always be preflighted.</p>
<h3 id="simplerequests">Simple requests</h3>
<p>Some requests are always considered safe to send and don't need a preflight if they meet all of the following conditions:</p>
<ul>
<li><strong>The method is:</strong>
<ul>
<li>GET</li>
<li>HEAD</li>
<li>POST</li>
</ul>
</li>
<li><strong>Have only these headers:</strong>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ul>
</li>
<li><strong>The <code>Content-Type</code> header is:</strong>
<ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
</li>
<li>No <code>ReadableStream</code> or event listeners in <code>XMLHttpRequestUpload</code> are used.</li>
</ul>
<p>In our example API, <code>GET</code> requests don't need to be preflighted because no JSON data is being sent, and so the app doesn't need to use the <code>Content-Type: application/json</code> header. They will always be simple requests.</p>
<h2 id="corsheaders">CORS Headers</h2>
<h3 id="serverheadersresponse">Server Headers (Response)</h3>
<table>
<thead>
<tr>
<th>Header</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Access-Control-Allow-Origin</strong></td>
<td><code>origin</code> or <code>*</code></td>
<td>Specifies the origin to be allowed, like <code>http://localhost:8100</code> or <code>*</code> to allow all origins.</td>
</tr>
<tr>
<td><strong>Access-Control-Allow-Methods</strong></td>
<td><code>methods</code></td>
<td>Which methods are allowed when accessing the resource: <code>GET</code>, <code>HEAD</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>CONNECT</code>, <code>OPTIONS</code>, <code>TRACE</code>, <code>PATCH</code>.</td>
</tr>
<tr>
<td><strong>Access-Control-Allow-Headers</strong></td>
<td><code>headers</code></td>
<td>Used in response to a preflight request to indicate which headers can be used when making the actual request, aside from the <a href="#simple-requests">simple headers</a>, which are always allowed.</td>
</tr>
<tr>
<td>Access-Control-Allow-Credentials</td>
<td><code>true</code> or <code>false</code></td>
<td>Whether or not the request can be made with credentials.</td>
</tr>
<tr>
<td>Access-Control-Expose-Headers</td>
<td><code>headers</code></td>
<td>Whitelists the headers that the browser is allowed to access.</td>
</tr>
<tr>
<td>Access-Control-Max-Age</td>
<td><code>seconds</code></td>
<td>Indicates how long the results of a preflight request can be cached.</td>
</tr>
</tbody>
</table>
<h3 id="browserheadersrequest">Browser Headers (Request)</h3>
<p>The browser automatically sends the appropriate headers for CORS in every request to the server, including the preflight requests. Please note that the headers below are for reference only, and <strong>should not be set in your app code</strong> (the browser will ignore them).</p>
<h4 id="allrequests">All Requests</h4>
<table>
<thead>
<tr>
<th>Header</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Origin</strong></td>
<td><code>origin</code></td>
<td>Indicates the origin of the request.</td>
</tr>
</tbody>
</table>
<h4 id="preflightrequests">Preflight Requests</h4>
<table>
<thead>
<tr>
<th>Header</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Access-Control-Request-Method</strong></td>
<td><code>method</code></td>
<td>Used to let the server know what method will be used when the actual request is made.</td>
</tr>
<tr>
<td>Access-Control-Request-Headers</td>
<td><code>headers</code></td>
<td>Used to let the server know what non-simple headers will be used when the actual request is made.</td>
</tr>
</tbody>
</table>
<h2 id="solutionsforcorserrors">Solutions for CORS Errors</h2>
<h3 id="aenablingcorsinaserveryoucontrol">A. Enabling CORS in a server you control</h3>
<p>The correct and easiest solution is to enable CORS by returning the <a href="#server-headers-response-">right response headers</a> from the web server or backend and responding to preflight requests, as it allows to keep using <code>XMLHttpRequest</code>, <code>fetch</code>, or abstractions like <code>HttpClient</code> in Angular.</p>
<p>Ionic apps may be run from different origins, but only one origin can be specified in the <code>Access-Control-Allow-Origin</code> header. Therefore we recommend checking the value of the <code>Origin</code> header from the request and reflecting it in the <code>Access-Control-Allow-Origin</code> header in the response.</p>
<p>Please note that all of the <code>Access-Control-Allow-*</code> headers have to be sent from the server, and don't belong in your app code.</p>
<p>Here are some of the origins your Ionic app may be served from:</p>
<h4 id="capacitor">Capacitor</h4>
<table>
<thead>
<tr>
<th>Platform</th>
<th>Origin</th>
</tr>
</thead>
<tbody>
<tr>
<td>iOS</td>
<td><code>capacitor://localhost</code></td>
</tr>
<tr>
<td>Android</td>
<td><code>http://localhost</code></td>
</tr>
</tbody>
</table>
<p>Replace <code>localhost</code> with your own hostname if you have changed the default in the Capacitor config.</p>
<h4 id="ionicwebview3xpluginoncordova">Ionic WebView 3.x plugin on Cordova</h4>
<table>
<thead>
<tr>
<th>Platform</th>
<th>Origin</th>
</tr>
</thead>
<tbody>
<tr>
<td>iOS</td>
<td><code>ionic://localhost</code></td>
</tr>
<tr>
<td>Android</td>
<td><code>http://localhost</code></td>
</tr>
</tbody>
</table>
<p>Replace <code>localhost</code> with your own hostname if you have changed the default in the plugin config.</p>
<h4 id="ionicwebview2xpluginoncordova">Ionic WebView 2.x plugin on Cordova</h4>
<table>
<thead>
<tr>
<th>Platform</th>
<th>Origin</th>
</tr>
</thead>
<tbody>
<tr>
<td>iOS</td>
<td><code>http://localhost:8080</code></td>
</tr>
<tr>
<td>Android</td>
<td><code>http://localhost:8080</code></td>
</tr>
</tbody>
</table>
<p>Replace port <code>8080</code> with your own if you have changed the default in the plugin config.</p>
<h4 id="localdevelopmentinthebrowser">Local development in the browser</h4>
<table>
<thead>
<tr>
<th>Command</th>
<th>Origin</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ionic serve</code></td>
<td><code>http://localhost:8100</code> or <code>http://YOUR_MACHINE_IP:8100</code></td>
</tr>
<tr>
<td><code>npm run start</code> or <code>ng serve</code></td>
<td><code>http://localhost:4200</code> for Ionic Angular apps.</td>
</tr>
</tbody>
</table>
<p>Port numbers can be higher if you are serving multiple apps at the same time.</p>
<br>
<p>Allowing any origin with <code>Access-Control-Allow-Origin: *</code> is guaranteed to work in all scenarios but may have security implications — like some CSRF attacks — depending on how the server controls access to resources and use sessions and cookies.</p>
<p>For more information on how to enable CORS in different web and app servers, please check <a href="https://enable-cors.org" target="_blank" rel="noopener">enable-cors.org</a></p>
<p>CORS can be easily enabled in Express/Connect apps with the <a href="https://github.com/expressjs/cors" target="_blank" rel="noopener">cors</a> middleware:</p>
<pre><code class="language-javascript">const express = require('express');
const cors = require('cors');
const app = express();

const whitelist = [
  'capacitor://localhost',
  'ionic://localhost',
  'http://localhost',
  'http://localhost:8080',
  'http://localhost:8100'
];

// Reflect the origin if it's in the whitelist or not defined (cURL, Postman, etc.)
const corsOptions = {
  origin: (origin, callback) =&gt; {
    if (whitelist.includes(origin) || !origin) {
      callback(null, true);
    } else {
      callback(new Error('Origin not allowed by CORS'));
    }
  }
}

// Enable preflight requests for all routes
app.options('*', cors(corsOptions));

app.get('/', cors(corsOptions), (req, res, next) =&gt; {
  res.json({ message: 'This route is CORS-enabled for a whitelisted origin.' });
})

app.listen(3000, () =&gt; {
  console.log('CORS-enabled web server listening on port 3000');
});
</code></pre>
<h3 id="bworkingaroundcorsinaserveryoucantcontrol">B. Working around CORS in a server you can't control</h3>
<h4 id="dontleakyourkeys">Don't leak your keys!</h4>
<p>If you are trying to connect to a 3rd-party API, first check in its documentation that is safe to use it directly from the app (client-side) and that it won't leak any secret/private keys or credentials, as it's easy to see them in clear text in Javascript code. Many APIs don't support CORS on purpose, in order to force developers to use them in the server and protect important information or keys.</p>
<h4 id="1nativeonlyappsiosandroid">1. Native-only apps (iOS/Android)</h4>
<p>Use the <a href="https://fdezromero.com/docs/native/http/" target="_blank" rel="noopener">HTTP plugin from Ionic Native</a> to make the requests natively from outside the webview. Please note that this plugin doesn't work in the browser, so the development and testing of the app must always be done in a device or simulator going forward.</p>
<p><strong>Usage in Ionic Angular 4</strong></p>
<pre><code class="language-typescript">import { Component } from '@angular/core';
import { HTTP } from '@ionic-native/http/ngx';

@Component({
  selector: 'app-home',
  templateUrl: './home.page.html',
  styleUrls: ['./home.page.scss'],
})
export class HomePage {
  constructor(private http: HTTP) {}

  async getData() {
    try {
      const url = 'https://api.example.com';
      const params = {};
      const headers = {};

      const response = await this.http.get(url, params, headers);

      console.log(response.status);
      console.log(JSON.parse(response.data)); // JSON data returned by server
      console.log(response.headers);

    } catch (error) {
      console.error(error.status);
      console.error(error.error); // Error message as string
      console.error(error.headers);
    }
  }
}
</code></pre>
<h4 id="2nativepwas">2. Native + PWAs</h4>
<p>Send the requests through an HTTP/HTTPS proxy that bypasses them to the external resources and adds the necessary CORS headers to the responses. This proxy must be trusted or under your control, as it will be intercepting most traffic made by the app.</p>
<p>Also, keep in mind that the browser or webview will not receive the original HTTPS certificates but the one being sent from the proxy if it's provided. URLs may need to be rewritten in your code in order to use the proxy.</p>
<p>Check <a href="https://github.com/Rob--W/cors-anywhere/" target="_blank" rel="noopener">cors-anywhere</a> for a Node.js CORS proxy that can be deployed in your own server. Using free hosted CORS proxies in production is not recommended.</p>
<h3 id="cdisablingcorsorbrowserwebsecurity">C. Disabling CORS or browser web security</h3>
<p>Please be aware that CORS exists for a reason (security of user data and to prevent attacks against your app). <strong>It's not possible or advisable to try to disable CORS</strong>.</p>
<p>Older webviews like <code>UIWebView</code> on iOS don't enforce CORS but are deprecated and are very likely to disappear soon. Modern webviews like iOS <code>WKWebView</code> or Android <code>WebView</code> (both used by Capacitor) do enforce CORS and provide huge security and performance improvements.</p>
<p>If you are developing a PWA or testing in the browser, using the <code>--disable-web-security</code> flag in Google Chrome or an extension to disable CORS is a really bad idea. You will be exposed to all kind of attacks, you can't ask your users to take the risk, and your app won't work once in production.</p>
<p><strong>Sources</strong></p>
<ul>
<li><a href="https://fdezromero.com/cors-errors-in-ionic-apps" target="_blank" rel="noopener">CORS Errors in Ionic Apps</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content:encoded></item><item><title><![CDATA[How I Host this Static Ghost Blog on Github Pages with wget]]></title><description><![CDATA[Generating a static site from a local Ghost blog with wget instead of Buster and hosting it at GitHub Pages.]]></description><link>https://fdezromero.com/how-i-host-this-static-ghost-blog-on-github-pages-with-wget/</link><guid isPermaLink="false">5bf2dae9d5546074beaea791</guid><category><![CDATA[Web]]></category><dc:creator><![CDATA[Rodrigo Fernández]]></dc:creator><pubDate>Mon, 19 Nov 2018 17:19:17 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1508780709619-79562169bc64?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=89d7af25dada5ebfb09405ae87cf372f" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1508780709619-79562169bc64?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=89d7af25dada5ebfb09405ae87cf372f" alt="How I Host this Static Ghost Blog on Github Pages with wget"><p>Lately I've been wanting to go back to writing more on my personal blog, so I'm currently in the process of gathering articles, slides, videos and code samples I wrote on various platforms.</p><p>Initially I wanted to write articles and pages in Markdown, generate some static blog pages from them, push to a repository, and host them in GitHub Pages. I tried several approaches, including building my blog off the <a href="https://github.com/ionic-team/stencil-site">great Stencil site generator</a>. But then decided that I didn't want to deal too much with templates and design, or I would spend more time coding and I'd never get to writing 😙</p><p>Coming from Medium, I liked Ghost's design and simplicity the most. Keeping another Node.js server with NGNIX and MySQL, backups and so on, not so much 😅. I found some middle ground installing Ghost locally (with the database in a SQLite file I can commit to a repo) and generating a static site with all the articles and pages.</p><p>I found many how-to's using Buster, a Python tool that automates the process of grabbing every page generating the site. The problem is that I soon noticed that the tool is no longer maintained and many things have changed in Ghost after it was last updated, so the result is essentially broken. I spent the rest of the day trying all the other forks with different results: some fixed some things and others fixed some other things. Either links were still pointing to localhost or pages were missing.</p><p>Then I remembered that the fantastic <code>wget</code> command has some backup and mirroring features, which Buster were also using under the hood. So I wrote a very simple bash script to automate the static generation process.</p><p>Here are the steps I followed to set up this blog. If you have a local Ghost installation, you can skip ahead to the script.</p><hr><h3 id="installing-ghost-locally">Installing Ghost locally</h3><p>To <a href="https://docs.ghost.org/install/local/">install Ghost locally</a> you will need the following:</p><ul><li>A supported version of <strong>Node.js</strong></li><li><strong>npm</strong> or <strong>yarn</strong> to manage packages</li><li>A clean, empty directory on your machine</li></ul><p>Ghost has a nice CLI tool we can install globally to handle multiple blogs:</p><pre><code class="language-bash">npm install -g ghost-cli
</code></pre>
<p>Then we need to create the empty directory were we want to store the blog, <code>cd</code> into it and run the local install command:</p><pre><code class="language-bash">ghost install local
</code></pre>
<p>After that, the blog will be installed in this directory and served at <code>https://fdezromero.com</code>, if you don't have previous Ghost installations. The admin is accessible from <code>https://fdezromero.com/ghost</code>.</p><p>The database file is located at <code>content/data</code>, in case you want to keep a backup in a private repo.</p><h3 id="generating-the-static-site">Generating the static site</h3><p>Once we have set up our Ghost blog, edited our user, created some articles and pages or installed a different theme, let's generate the static site so it can be served by GitHub Pages (or Firebase, Netlify, etc).</p><p>First, if you're using macOS like me, let's install <code>wget</code> via Homebrew. It's like the <code>apt-get</code> of macOS. If you use Linux you should have it already installed.</p><pre><code class="language-bash">brew install wget
</code></pre>
<p>And then to the final part, the bash script. I saved it at the root directory of the blog, and called it <code>generate.sh</code>:</p><pre><code class="language-bash">#!/bin/bash

# Copy blog content
wget --recursive --no-host-directories --directory-prefix=static --adjust-extension --timeout=30 --no-parent --convert-links https://fdezromero.com/

# Copy 404 page
wget --no-host-directories --directory-prefix=static --adjust-extension --timeout=30 --no-parent --convert-links --content-on-error --timestamping https://fdezromero.com/404.html

# Copy sitemaps
wget --recursive --no-host-directories --directory-prefix=static --adjust-extension --timeout=30 --no-parent --convert-links https://fdezromero.com/sitemap.xsl
wget --recursive --no-host-directories --directory-prefix=static --adjust-extension --timeout=30 --no-parent --convert-links https://fdezromero.com/sitemap.xml
wget --recursive --no-host-directories --directory-prefix=static --adjust-extension --timeout=30 --no-parent --convert-links https://fdezromero.com/sitemap-pages.xml
wget --recursive --no-host-directories --directory-prefix=static --adjust-extension --timeout=30 --no-parent --convert-links https://fdezromero.com/sitemap-posts.xml
wget --recursive --no-host-directories --directory-prefix=static --adjust-extension --timeout=30 --no-parent --convert-links https://fdezromero.com/sitemap-authors.xml
wget --recursive --no-host-directories --directory-prefix=static --adjust-extension --timeout=30 --no-parent --convert-links https://fdezromero.com/sitemap-tags.xml

# Replace localhost with domain
LC_ALL=C find ./static -type f -not -wholename *.git* -exec sed -i '' -e 's/http:\/\/fdezromero.com/https:\/\/fdezromero.com/g' {} +
LC_ALL=C find ./static -type f -not -wholename *.git* -exec sed -i '' -e 's/fdezromero.com/fdezromero.com/g' {} +
LC_ALL=C find ./static -type f -not -wholename *.git* -exec sed -i '' -e 's/http:\/\/www.gravatar.com/https:\/\/www.gravatar.com/g' {} +

# Set up Github Pages CNAME
echo &quot;fdezromero.com&quot; &gt; static/CNAME
</code></pre>
<p>In order to adapt it to your blog, replace all the occurrences of <code>fdezromero.com</code> with your port number if different, and <code>fdezromero.com</code> with your own domain or subdomain. You can also use the subdomain provided by GitHub Pages, like <code>username.github.io</code>.</p><p>Notice that all the script does is to start crawling all links from the home page and converting them to relative when possible. Then the same with the sitemaps for better SEO. At the end, it replaces any broken link still pointing to the local installation and creates the <code>CNAME</code> file needed by GitHub Pages to use your own custom domain.</p><p>Once we have the script configured, we just need to give it execution permissions and run it:</p><pre><code class="language-bash">chmod +x generate.sh
./generate.sh
</code></pre>
<p>If the blog is up, the script will scrape its contents and you'll have a static copy of your blog in the <code>static</code> directory. From here, you can initialize a git repo and push the site to GitHub:</p><pre><code class="language-bash">cd static
git init
git remote add origin https://github.com/user/repo.git
git push master origin
</code></pre>
<p>And finish configuring your custom domain or subdomain to point to your blog <a href="https://help.github.com/articles/quick-start-setting-up-a-custom-domain/">with this guide</a>.</p>]]></content:encoded></item><item><title><![CDATA[Tips & Tricks for Ionic on Desktop]]></title><description><![CDATA[In the process of customizing Savelist for larger screens, we collected some tips & tricks that we wanted to share that could help you adapt your app for the desktop, without compromising the mobile experience we already had.]]></description><link>https://fdezromero.com/tips-and-tricks-for-ionic-on-desktop/</link><guid isPermaLink="false">5bf44b2b00458904fdb03c87</guid><category><![CDATA[Ionic]]></category><dc:creator><![CDATA[Rodrigo Fernández]]></dc:creator><pubDate>Thu, 15 Feb 2018 11:00:00 GMT</pubDate><media:content url="https://fdezromero.com/content/images/2018/11/desktop-trick-img.jpg" medium="image"/><content:encoded><![CDATA[<img src="https://fdezromero.com/content/images/2018/11/desktop-trick-img.jpg" alt="Tips & Tricks for Ionic on Desktop"><p><em>Originally published in <a href="https://blog.ionicframework.com/tips-tricks-for-ionic-on-desktop/">The Official Ionic Blog</a>.</em></p><p>We have been using Ionic at <a href="http://savelist.co/" rel="noopener">Savelist</a> since the first alpha versions, and always thought that one of its strongest benefits is the ability to code an app for iOS, Android and the Web with a single codebase. Heck, we even use Ionic to build our browser extensions!</p><p>When we went through the process of launching the Savelist Progressive Web App in January (2017), we noticed that even though it looked as expected on mobile – as we started with a “mobile first” approach – it didn’t look quite right on the larger displays of laptops and desktops. Navigation bars and content were too wide and since most content was aligned to the left, there was too much white space on the right of almost all our screens. It felt more like the maximized version of our Android app than a website.</p><p>In the process of customizing Savelist for larger screens, we collected some tips &amp; tricks that we wanted to share that could help you adapt your app for the desktop, without compromising the mobile experience we already had.</p><p>This guide is based on the latest release of <code>ionic-angular</code> at the time (3.9.2). If you’re using an older version of Ionic, I strongly recommend you to update to the latest release.</p><h3 id="setting-up-the-fixed-grid">Setting up the fixed grid</h3><p>Ionic has a great grid system based on flexbox that we can use to adapt content and make it responsive. It’s incredibly customizable, and we can define custom grid widths and breakpoints for every resolution.</p><p>First, we limited the grid width in order to make the content easier to navigate. For our needs, all we had to do was removed the <code>xl</code> breakpoint. Ionic handles this without any issues.</p><p>In our <code>src/theme/variables.scss</code>:</p><pre><code class="language-scss">$grid-breakpoints: (
 xs: 0, // Phone (0px - 575px)
 sm: 576px, // Phablet (576px - 767px)
 md: 768px, // Tablet vertical (768px - 991px)
 lg: 992px // Tablet horizontal, Desktop (992px and above)
);
</code></pre>
<p>Next we modified the <code>$grid-max-widths</code> variable and made our app use 100% of the width until it reaches 992px:</p><pre><code class="language-scss">$grid-max-widths: (
 lg: 992px
);
</code></pre>
<p>You could use any other size you’d want for this, as long as the value <code>lg</code>from <code>$grid-breakpoints</code> matches.</p><h3 id="using-the-fixed-grid-on-pages">Using the fixed grid on pages</h3><p>In order to apply a max-width to our pages, we just wrap the markup inside <code>&lt;ion-content&gt;</code> with <code>&lt;ion-grid fixed&gt;</code>. The <code>fixed</code> attribute tells Ionic’s grid to use the max-width corresponding to the current breakpoint, or 100% if not defined.</p><p>So this code:</p><pre><code class="language-html">&lt;ion-content&gt;
 &lt;!-- Some code --&gt;
&lt;/ion-content&gt;
</code></pre>
<p>Becomes:</p><pre><code class="language-html">&lt;ion-content&gt;
 &lt;ion-grid fixed&gt;
   &lt;!-- Some code --&gt;
 &lt;/ion-grid&gt;
&lt;/ion-content&gt;
</code></pre>
<p>We don’t need to apply this to pages that are displayed inside modals or popovers, as they already have a fixed width.</p><h3 id="horizontally-center-the-header-footer-toolbars">Horizontally center the header &amp; footer toolbars</h3><p>We have better looking pages now, but the toolbars inside <code>&lt;ion-header&gt;</code> and <code>&lt;ion-footer&gt;</code> are not horizontally aligned. We can easily adjust them to match of our fixed-width pages by adding these rules at the end of <code>app.scss</code>:</p><pre><code class="language-scss">// Desktop

ion-header .toolbar {
 margin: auto;
}

@media (min-width: map-get($grid-breakpoints, lg)) {
 ion-navbar.toolbar,
 ion-header .toolbar[fixed],
 ion-footer .toolbar[fixed],
 ion-tabs .tabbar {
   margin: 0;
   padding-right: calc((100% - #{map-get($grid-max-widths, lg)}) / 2);
   padding-left: calc((100% - #{map-get($grid-max-widths, lg)}) / 2);
 }
}
</code></pre>
<p>If there is any <code>&lt;ion-toolbar&gt;</code> inside <code>&lt;ion-header&gt;</code> or <code>&lt;ion-footer&gt;</code>, you may want to add the <code>fixed</code> attribute to center them, like <code>&lt;ion-toolbar fixed&gt;</code>.</p><h3 id="showing-tabs-at-the-top">Showing tabs at the top</h3><p>While users are used to having tabs at the bottom in mobile apps, desktop webs usually show them at the top for better usability and navigation. Well known apps like Twitter, Pinterest and Instagram all use tabs at the top for their desktop experience.</p><p>Fortunately, Ionic Framework allows us to easily customize the position and layout of the tabs, so we can have bottom tabs with icons on top in our mobile experience:</p><figure class="kg-card kg-image-card"><img src="https://fdezromero.com/content/images/2018/11/image.png" class="kg-image" alt="Tips & Tricks for Ionic on Desktop"></figure><p>And top tabs with icons on the left for our desktop experience:</p><figure class="kg-card kg-image-card"><img src="https://fdezromero.com/content/images/2018/11/image-1.png" class="kg-image" alt="Tips & Tricks for Ionic on Desktop"></figure><p>To achieve this we can bind class properties to the <code>tabsPlacement</code> and <code>tabsLayout</code> attributes of our <code>&lt;ion-tabs&gt;</code>:</p><pre><code class="language-html">&lt;ion-tabs [tabsPlacement]=&quot;tabsPlacement&quot; [tabsLayout]=&quot;tabsLayout&quot;&gt;
    &lt;!-- Tabs here --&gt;
&lt;ion-tabs&gt;
</code></pre>
<p>And set the values depending on the platform:</p><pre><code class="language-ts">@Component({
  templateUrl: 'app.html'
})
export class AppComponent {
  tabsPlacement: string = 'bottom';
  tabsLayout: string = 'icon-top';

  constructor(
    public platform: Platform,
  ) {
    if (!this.platform.is('mobile')) {
      this.tabsPlacement = 'top';
      this.tabsLayout = 'icon-left';
    }
  }
}
</code></pre>
<p>You can check the different placement and layout options in the <a href="https://ionicframework.com/docs/api/components/tabs/Tabs/">Tabs docs</a>.</p><h3 id="using-the-responsive-grid-and-breakpoints">Using the responsive grid and breakpoints</h3><p>One of Savelist’s key features is the ability to show all the products you have saved from the web in a clear and organized layout, so cards in a responsive grid was the best way to go in displaying that information.</p><p>This option lets you have one or two cards per row on mobile, and more cards as the screen gets bigger. Cards don’t have a fixed width and make the best use of the available space.</p><figure class="kg-card kg-image-card"><img src="https://fdezromero.com/content/images/2018/11/image-2.png" class="kg-image" alt="Tips & Tricks for Ionic on Desktop"><figcaption>Mobile</figcaption></figure><figure class="kg-card kg-image-card"><img src="https://fdezromero.com/content/images/2018/11/image-3.png" class="kg-image" alt="Tips & Tricks for Ionic on Desktop"><figcaption>Tablet</figcaption></figure><figure class="kg-card kg-image-card"><img src="https://fdezromero.com/content/images/2018/11/image-4.png" class="kg-image" alt="Tips & Tricks for Ionic on Desktop"><figcaption>Desktop</figcaption></figure><p>It’s easy to achieve this layout with the help of the grid breakpoints we set up before and <code>col-{breakpoint}-{#}</code>:</p><pre><code class="language-html">&lt;ion-grid fixed&gt;
 &lt;ion-row&gt;
   &lt;ion-card ion-col *ngFor=&quot;let product of products&quot; col-6 col-md-4 col-lg-3&gt;&lt;/ion-card&gt;
 &lt;/ion-row&gt;
&lt;/ion-grid&gt;
</code></pre>
<p>Rows will start with 2 cards on <code>xs</code> and <code>sm</code>, 3 cards on <code>md</code> and 4 cards on <code>lg</code> and above.</p><h3 id="adapting-the-experience">Adapting the experience</h3><p>We have addressed the biggest points of adapting the PWA “app shell” to big screens. However, you may still notice some items that you want to show differently, like font size, images, UI, etc.</p><p>There is no silver bullet for this, but you can achieve almost anything you want starting with this media query, so if you ever change the <code>lg</code> breakpoint the media query will update as well:</p><pre><code class="language-scss">@media (min-width: map-get($grid-breakpoints, lg)) {
 // Your rules here
}
</code></pre>
<p>Another way is to show or hide elements according to the platform type instead of the screen size with <code>showWhen</code> and <code>hideWhen</code>. You can use the value <code>core</code> to target desktops.</p><hr><h3 id="share-your-tricks-">Share your tricks!</h3><p>This was just a few of the changes we made to Savelist in order to look better on larger screens, but I’m sure there’s more ideas out there. I’d love to know what tricks you have in your bag with working with Ionic, so leave a comment below!</p>]]></content:encoded></item><item><title><![CDATA[Injecting Providers into Async Custom Validators in Angular]]></title><description><![CDATA[One of the first things developers do when we are building a new app is a signup form, that checks that every field is okay and shows an appropriate error message if it’s not.]]></description><link>https://fdezromero.com/injecting-providers-into-async-custom-validators-in-angular/</link><guid isPermaLink="false">5bf1fb12e38f017290dd07aa</guid><category><![CDATA[Angular]]></category><category><![CDATA[Ionic]]></category><dc:creator><![CDATA[Rodrigo Fernández]]></dc:creator><pubDate>Thu, 09 Feb 2017 11:00:00 GMT</pubDate><media:content url="https://fdezromero.com/content/images/2018/11/jantine-doornbos-398339-unsplash.jpg" medium="image"/><content:encoded><![CDATA[<img src="https://fdezromero.com/content/images/2018/11/jantine-doornbos-398339-unsplash.jpg" alt="Injecting Providers into Async Custom Validators in Angular"><p>One of the first things developers do when we are building a new app is a signup form, that checks that every field is okay and shows an appropriate error message if it’s not.</p><p>It’s also a common practice to check if the typed email is already registered or if the username is taken. Angular has some basic validators built in, but in order to check our API and return the status we need to write a custom async validator. Please read this great guide about <a href="https://www.joshmorony.com/advanced-forms-validation-in-ionic-2/" rel="noopener">Advanced Forms &amp; Validation in Ionic 2</a> by Josh Morony first.</p><p>The only part missing in the guide is to actually inject the provider in charge of connecting to our API and getting the result. This is a bit tricky since <strong>async validators need to have static properties and we can’t inject a provider directly</strong>, so we will have to pass it to the validator class by using its constructor. This will work from Angular 2 onwards, I’m using Ionic 2.</p><p>Here is how I solved it. If you know any way to improve this code, please leave a comment with a link to your code!</p><pre><code class="language-ts">import { FormControl } from '@angular/forms';
import { UserService } from '../../providers/user-service/user-service';

export class UserValidator {
  static userService: UserService;
  static EMAIL_REGEXP = /.+@.+\..+/;

  constructor(userService: UserService) {
    UserValidator.userService = userService;
  }

  // Async validator: `new UserValidator(userService).checkEmailAvailable`

  checkEmailAvailable(input: FormControl) {
    if (!input.value || !UserValidator.EMAIL_REGEXP.test(input.value)) {
      return Promise.resolve({ invalid: true });
    }

    return UserValidator.userService.checkEmail(input.value)
    .then(data =&gt; data &amp;&amp; data.available ? null : data)
    .catch(err =&gt; console.error(err));
  }
}
</code></pre>
<p>We start making our class properties static, then we inject the provider UserService into the constructor. Because we have defined <code>userService</code> as static, we can assign the reference to the provider by using the Class.property syntax.</p><p>The validator function is actually very simple: it returns <code>null</code> if there aren’t any errors, or an object with every error set to true. My API actually returns <code>{ available: true }</code> if everything is okay and then I convert that to null, but you may handle this differently.</p><p>Now every time we want to use this validator, we need to call it from our parent class like <code>new UserValidator(userService).checkEmailAvailable</code> .</p><p>With this snippet, it would be fairly simple to create another validator function inside the <code>UserValidator</code> class to check if a username is taken or not.</p>]]></content:encoded></item><item><title><![CDATA[How To Connect Virtual Networks through a VPN in the New Azure Portal (Resource Manager)]]></title><description><![CDATA[This article covers a very common use case for startups using Microsoft Azure and BizSpark: how to connect virtual machines from two virtual networks in different subscriptions (or regions) with the new Azure Portal (Resource Manager or ARM).]]></description><link>https://fdezromero.com/how-to-connect-virtual-networks-through-a-vpn-in-the-new-azure-portal-resource-manager/</link><guid isPermaLink="false">5bf1d4f63511de70fc804a35</guid><category><![CDATA[Azure]]></category><category><![CDATA[Startups]]></category><dc:creator><![CDATA[Rodrigo Fernández]]></dc:creator><pubDate>Fri, 01 Apr 2016 10:00:00 GMT</pubDate><media:content url="https://fdezromero.com/content/images/2018/11/1_KXZKF9RkS1Tdr0yYFGcY6Q.jpg" medium="image"/><content:encoded><![CDATA[<img src="https://fdezromero.com/content/images/2018/11/1_KXZKF9RkS1Tdr0yYFGcY6Q.jpg" alt="How To Connect Virtual Networks through a VPN in the New Azure Portal (Resource Manager)"><p>This article covers a very common use case for startups using Microsoft Azure and BizSpark: how to connect virtual machines from two virtual networks in different subscriptions (or regions) with the new Azure Portal (Resource Manager or ARM).</p><p>The BizSpark program gives startups like <a href="https://savelist.co/?utm_source=engineering_blog" rel="noopener">Savelist</a> free Azure credits for up to 3 years. The catch is that these credits are divided in several subscriptions with $150/€130 each (one per team member). In order to get the most out of the BizSpark credits, you’ll want to use more than one subscription, but all the resources you create are bound to that subscription. The <em>easiest</em> (note I didn’t write <em>easy</em>) way is to connect the virtual networks through a VPN at the infrastructure level, using what Azure calls <strong><strong>Virtual Network Gateways</strong></strong>.</p><h4 id="so-to-be-clear-this-article-supposes-that-">So to be clear, this article supposes that:</h4><ul><li>Your VMs and virtual networks were created in the <strong><strong>new Azure Portal</strong></strong>(<strong><strong>Resource Manager</strong></strong> mode or ARM), not the old Classic Portal (Service Manager mode or ASM) .</li><li>These VMs are in <strong><strong>different virtual networks</strong></strong>. It doesn’t matter if they are in the same subscription, in other subscription or in another Azure location. We’ll connect them with a secure VPN that will route the traffic over the Internet (but inside the Azure backbone). If they are in the same virtual network, the VMs will just see each other and you don’t need any of this.</li><li>You want to use the <strong><strong>Azure Portal</strong></strong> instead of the Azure CLI or PowerShell. Because we are cool dev hipsters, not SysAdmins from the 90s (although the Azure CLI is wrote in NodeJS and that’s also cool).</li></ul><hr><h4 id="requirements">Requirements</h4><p>Before we can connect the virtual networks, there are some requirements and considerations:</p><ul><li>The <strong><strong>address spaces</strong></strong> of the virtual networks <strong><strong>cannot collide</strong></strong>. If they did, when a VM wanted to connect to a local IP, the virtual network wouldn’t know how to route this request.</li><li>We will need to <strong><strong>create two Virtual Network Gateways</strong></strong>, one for each network. These cost around $27/€23 a piece (in March 2016).</li><li>You may also have to pay for <strong><strong>outbound data traffic sent between the networks</strong></strong> if they are in different regions or outside of Azure, as the VPN connection will be established using public IPs, and therefore routed through the Internet. You won’t be charged twice, as inbound traffic is always free.</li></ul><h4 id="deployment-overview">Deployment Overview</h4><p>These are all the resources we will use. I’ll be using the letters <strong><strong>a</strong></strong> and <strong><strong>b</strong></strong> to refer to each side of the connection. You can name them whatever you want but I recommend writing your equivalent in a cheat sheet:</p><ul><li>2 existing Virtual Networks: <strong><strong>network-a</strong></strong> and <strong><strong>network-b</strong></strong>.</li><li>2 or more existing Subnets: <strong><strong>subnet-a</strong></strong> and <strong><strong>subnet-b</strong></strong>, inside <em>network-a</em> and <em>network-b</em>, respectively.</li><li>2 new Virtual Network Gateways: <strong><strong>vpn-gateway-a</strong></strong> and <strong><strong>vpn-gateway-b</strong></strong>.</li><li>2 new Public IP addresses for the Virtual Network Gateways: <strong><strong>vpn-ip-a</strong></strong> and <strong><strong>vpn-ip-b</strong></strong>.</li><li>2 new Local Network Gateways: <strong><strong>local-gateway-a</strong></strong> and <strong><strong>local-gateway-b</strong></strong>.</li><li>2 new Connections: <strong><strong>vpn-connection-a</strong></strong> and <strong><strong>vpn-connection-b</strong></strong>.</li></ul><p>In the example I will be also considering that you have 2 different subscriptions, resource groups and locations.</p><blockquote>If you have your virtual networks under the same subscription, resource group or location it’s okay, just consider that the following are the same in your case.</blockquote><ul><li>iptions: <strong><strong>subscription-a</strong></strong> and <strong><strong>subscription-b</strong></strong> (can be the same).</li><li>2 Resource Groups: <strong><strong>resource-group-a</strong></strong> and <strong><strong>resource-group-b</strong></strong> (can be the same).</li><li>2 Locations: <strong><strong>location-a</strong></strong> and <strong><strong>location-b</strong></strong> (can be the same).</li></ul><h4 id="network-specs">Network Specs</h4><p>These are the specs of the two networks. Notice that the IP address spaces are different, so they don’t collide. If they do now, you will have to change the address space in one of them before you continue.</p><pre><code>network-a
  Address space: 10.0.0.0/16
  Subnets:
    subnet-a: 10.0.0.0/24
network-b
  Address space: 10.1.0.0/16
  Subnets:
    subnet-b: 10.1.0.0/24
</code></pre>
<h3 id="1-create-the-gateway-subnets">1. Create the Gateway Subnets</h3><p>The Virtual Network Gateways that we will create in the next step need that the networks have a special subnet inside exactly named <strong><strong>GatewaySubnet</strong></strong>. If you already have them just skip this step.</p><p>Go to <em>Virtual networks &gt; Settings &gt; Subnets</em> and click the add Gateway subnet button. Choose an address space inside <strong><strong>network-a</strong></strong> that is bigger or equal to /29 and that doesn’t collide with the other subnets. For simplicity, I’m using /24. Repeat the steps with <strong><strong>network-b</strong></strong> so you end up with something like this:</p><pre><code>network-a
  Address space: 10.0.0.0/16
  Subnets:
    subnet-a: 10.0.0.0/24
    GatewaySubnet: 10.0.1.0/24
network-b
  Address space: 10.1.0.0/16
  Subnets:
    subnet-b: 10.1.0.0/24
    GatewaySubnet: 10.1.1.0/24
</code></pre>
<h3 id="2-create-the-virtual-network-gateways">2. Create the Virtual Network Gateways</h3><p>Go to <em>Virtual network gateways &gt; Add</em> and select the following:</p><pre><code>Name: vpn-gateway-a
Virtual network: network-a
Public IP address: vpn-ip-a (new)
Gateway type: VPN
VPN type: Route-based
Subscription: subscription-a
Resource group: resource-group-a
Location: location-a
</code></pre>
<p>Repeat the steps for the other subscription/network:</p><pre><code>Name: vpn-gateway-b
Virtual network: network-b
Public IP address: vpn-ip-b (new)
Gateway type: VPN
VPN type: Route-based
Subscription: subscription-b
Resource group: resource-group-b
Location: location-b
</code></pre>
<p>The deploy can take up to 45 minutes, but we can set some other things up meanwhile.</p><h3 id="3-find-the-ip-addresses">3. Find the IP addresses</h3><p>When the deploy of the previous step starts, you will have 2 new public IP addresses, <strong><strong>vpn-ip-a</strong></strong> and <strong><strong>vpn-ip-b</strong></strong>. It’s okay if the Virtual Network gateways are still deploying because the IPs are created at the beginning. If there aren’t there just wait a couple of minutes and refresh the list.</p><p>Go to <em>Public IP addresses, </em>select <strong><strong>vpn-ip-a</strong></strong> and write down its number because we will need it later on. Do the same for <strong><strong>vpn-ip-b</strong></strong>. Let’s say these are my public IPs (yours will be different):</p><pre><code>vpn-ip-a: 40.84.0.1
vpn-ip-b: 40.84.0.2
</code></pre>
<h3 id="4-create-the-local-network-gateways">4. Create the Local Network Gateways</h3><p>This is the tricky part that took me a couple of hours to figure out. In each side of the VPN, we have a virtual network with a virtual gateway (probably still deploying) that acts as a door to the outside Internet that sends and receives traffic to the other end. But we need something to tell our virtual network “hey, for these local IP address outside your address space, you will have to get them through the door at 40.84.0.X”.</p><p>So <strong><strong>network-a</strong></strong> needs to know that the 10.1.0.0/16 range, that is outside its address space (10.0.0.0/16), is reachable through <strong><strong>vpn-ip-b</strong></strong> (40.84.0.2). And <strong><strong>network-b</strong></strong> (10.1.0.0/16) needs to know that the outside space 10.0.0.0/16 is reachable through <strong><strong>vpn-ip-a</strong></strong> (40.84.0.1). This something is a <strong><strong>Local Network Gateway</strong></strong>.</p><p>Go to <em>Local network gateways &gt; Add</em> and create one for <strong><strong>network-a</strong></strong>:</p><pre><code>Name: local-gateway-b
IP address: 40.84.0.2 (vpn-ip-b)
Address space: 10.1.0.0/16
Subscription: subscription-a
Resource group: resource-group-a
Location: location-a
</code></pre>
<p>See what happened here? We created the <strong><strong>local-gateway-b</strong></strong> in the same subscription and resource group as <strong><strong>network-a</strong></strong>, with the public IP and address space of <strong><strong>network-b</strong></strong>. This is how <strong><strong>network-a</strong></strong> knows how to get to an IP from <strong><strong>network-b</strong></strong>.</p><p>Let’s now create the one for <strong><strong>network-b</strong></strong>:</p><pre><code>Name: local-gateway-a
IP address: 40.84.0.1 (vpn-ip-a)
Address space: 10.0.0.0/16
Subscription: subscription-b
Resource group: resource-group-b
Location: location-b
</code></pre>
<h3 id="5-create-the-connections">5. Create the Connections</h3><blockquote>From this point forward you need both Virtual Network Gateways to have finished deploying. If they haven’t, just chill out <a href="https://savelist.co/?utm_source=engineering_blog" rel="noopener">or have a look at what we do at Savelist</a>.</blockquote><p>With the Virtual Network Gateways deployed, we now need to create a connection between <strong><strong>local-gateway-b</strong></strong> and <strong><strong>vpn-gateway-a</strong></strong> (for <em>network-a</em>) and another between <strong><strong>local-gateway-a</strong></strong> and <strong><strong>vpn-gateway-b</strong></strong> (for <em>network-b</em>). This will complete the traffic routing.</p><pre><code>   network-a
local-gateway-b
 vpn-gateway-a
      ||
   Internet
      ||
 vpn-network-b
local-gateway-a
  network-b
</code></pre>
<p>Go to <em>Local network gateways</em> in <strong><strong>subscription-a</strong></strong> and select <strong><strong>local-gateway-b</strong></strong>and then<strong><strong> </strong></strong><em>Settings &gt; Connections &gt; Add</em>. The <em>Connection type</em> will already have <em>Site-to-site (IPsec)</em> selected and greyed out.</p><p>You can choose any mix of letters and numbers as your shared key (PSK), as long as you put the same in both <strong><strong>vpn-connection-a</strong></strong> and <strong><strong>vpn-connection-b</strong></strong>. It acts as a password to secure the connection.</p><blockquote>Pro tip: <a href="https://www.grc.com/passwords.htm" rel="noopener">The GRC site generates ultra secure passwords just for you through HTTPS</a>. I copied and pasted the one in the 3rd box.</blockquote><pre><code>Name: vpn-connection-b
Connection type: Site-to-site (IPsec)
Virtual network gateway: vpn-gateway-a
Local network gateway: local-gateway-b (locked)
Shared key (PSK): (choose a mix of letters and numbers)
Subscription: subscription-a
Location: location-a
</code></pre>
<p>Repeat the process for <strong><strong>local-gateway-a</strong></strong> in <strong><strong>subscription-b</strong></strong>:</p><pre><code>Name: vpn-connection-a
Connection type: Site-to-site (IPsec)
Virtual network gateway: vpn-gateway-b
Local network gateway: local-gateway-a (locked)
Shared key (PSK): (paste the same key as before)
Subscription: subscription-b
Location: location-b
</code></pre>
<p>If everything went well, after a few minutes the Virtual Networks Gateways will establish a connection and show with the <em>Connected</em> status. If it doesn’t work after 10 minutes, check that the IPs and address spaces in the Local Network Gateways are correct and from the <strong><strong>other</strong></strong> network.</p><h3 id="6-test-the-connection">6. Test the Connection</h3><p>You can just now log into a machine in <strong><strong>network-a</strong></strong> and try to access a machine in <strong><strong>network-b</strong></strong>, and viceversa. You will see the traffic increase in the connection details. If it doesn’t work, check the network security groups used by your virtual machines and/or virtual networks. If the VPN connection shows <em>Connected</em>, then is working fine and something else in your networks is blocking the communication.</p><hr><blockquote>Special thanks to <a href="https://twitter.com/DevStarlight" rel="noopener">Jesús Huerta</a>, who helped me translate the old and confusing articles from Microsoft to the newer Azure Portal and ARM.</blockquote>]]></content:encoded></item></channel></rss>
